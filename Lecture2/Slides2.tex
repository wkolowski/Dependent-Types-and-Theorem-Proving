\documentclass{beamer}

\usepackage{xcolor}

\newcommand{\m}[1]{\texttt{#1}}
\newcommand{\e}[1]{\textbf{#1}}

\newcommand{\notb}[1]{not #1}
\newcommand{\andb}[2]{#1 \&\& #2}
\newcommand{\orb}[2]{#1 || #2}
\newcommand{\implb}[2]{#1 ==> #2}
\newcommand{\iffb}[2]{#1 <=> #2}

\newcommand{\mnotb}[1]{\m{\notb{#1}}}
\newcommand{\mandb}[2]{\m{\andb{#1}{#2}}}
\newcommand{\morb}[2]{\m{\orb{#1}{#2}}}
\newcommand{\mimplb}[2]{\m{\implb{#1}{#2}}}
\newcommand{\miffb}[2]{\m{\iffb{#1}{#2}}}

\title{Dependent Types and Theorem Proving: \\Proving is programming in disguise}
\author{Wojciech KoÅ‚owski}
\date{March 2021}

\usetheme{Darmstadt}

\begin{document}

\frame{\titlepage}

\begin{frame}{Plan of lectures}
\begin{itemize}
	\item Lecture 1: Programming with dependent types.
	\item \textbf{Lecture 2: Proving theorems with dependent types.}
	\item Lecture 3: Differences between programming and proving.
	\item Lecture 4: Examples of bigger programs and longer proofs.
	\item Lecture 5: A deeper dive into F*.
\end{itemize}
\end{frame}

\frame{\tableofcontents}

\section{Introduction: boolean logic and classical logic}

\begin{frame}{The booleans and their logic}
\begin{itemize}
	\item Being a programmer, you are good friends with the booleans, aren't you?
	\item There are two booleans, \m{true} and \m{false}.
	\item We can combine booleans \m{b} and \m{c} with the usual boolean functions:
	\item \mnotb{b} -- negation, pronounced ``not \m{b}''
	\item \mandb{b}{c} -- conjunction, pronounced ``\m{b} and \m{c}''
	\item \morb{b}{c} -- disjunction, pronounced ``\m{b} or \m{c}''
	\item We can also define less commonly used boolean functions:
	\item \m{\implb{b}{c} = \orb{\notb{b}}{c}} -- implication, pronounced ``if \m{b} then \m{c}''
	\item \m{\iffb{b}{c} = \andb{\implb{b}{c}}{\implb{c}{b}}} -- logical equivalence, pronounced ``\m{b} if and only if \m{c}''
\end{itemize}
\end{frame}

\begin{frame}{Classical logic}
\begin{itemize}
	\item 
\end{itemize}
\end{frame}



\section{Constructive propositional logic: you already know it}

\subsection{Propositional logic}
% Describe the syntax of propositional logic.
% Explain the meaning of terms like "proposition" and
% the natural-language meaning of logical connectives.

\subsection{Propositions are types, proofs are programs}
% Explain the "propositions as types" paradigm.
% Make sure to strongly emphasize that in this
% interpretation logic is constructive and explain
% what that means. Point out differences from
% classical (i.e. boolean) logic.

\subsubsection{Function types are implications}
\subsubsection{Sum is disjunction}
\subsubsection{Product is conjunction}
\subsubsection{Unit is True}
% In the above subsubsections, explain the meaning of all connectives one by one.

\subsubsection{Falsity and negation}
% Introduce the empty type using the mechanism of
% algebraic data types.

% Introduce the proposition False as the
% "propositions are types" interpretation of the
% empty type.

% Introduce negation as an implication whose codomain
% is False. Explain the meaning of negation ~ P as
% there being some internal inconsistency in P.

% BEWARE! Remember to discuss ex falso carefully as this
% aspect of negation is neither intuitive to ordinary
% people nor to programmers (the empty type is not very
% useful in F# or Haskell).

% Optional: mention strong negation.

\section{Higher-order logic: you already know it}

\subsection{Predicates and relations}
% Explain the notions of predicate and relation and
% then introduce notation (i.e. A -> Type and A -> B -> Type).

\subsection{Universal quantifier is the dependent function type}
\subsection{Existential quantifier is the dependent pair type}
% Describe rules for quantifiers by referring back to dependent
% function and pair types from last lecture.
% Mention that F* can prove some propositions all by itself,
% using only the built-in SMT solvers.

\section{Induction is recursion}
% Start with a refresher on recursion.
% Examples: basic list functions -- append, reverse, etc.

% Then explain proofs by induction by analogy with recursive
% definitions.
% Examples: properties of basic list functions.

\section{Inductive predicates and relations}
% Explain how to interpret inductive families and predicates
% and relations. Examples: list permutations, being element
% of a list, there exists/all elements of a list satisfy
% some predicate, a list has duplicate elements, etc.

\subsection{Undecidability and generative thinking}
% Explain the difference between defining a function which
% checks if a property holds ("how to check" is a kind of
% top-down thinking) and defining a property as an inductive
% family ("how to generate all proofs of this" is a kind of
% bottom-up thinking).

\subsection{Proof relevance}
% Explain the notion of proof relevance, i.e. that there can
% be different proofs of some propositions, represented by
% different elements of the corresponding type. Example:
% being an element of a list.

\section{Equality}
% Some background on the classical definitions of equality
% by Aristotle and Leibniz.

\subsection{Definition and convertibility}
% Show how to define equality as an inductive family.

% Show some example proofs, like 2 + 2 = 4 or some
% more properties of list functions.

% Explain why this definition even makes sense by
% explaining how computation works and the notion
% of convertibility.

\subsection{Properties of equality}
% Prove basic properties of equality, like symmetry
% and transitivity.

% Also prove some characterizations of equality for
% some type formers, like pairs or sums.

\subsection{Caveat: equality of functions and types}
% Explain why we can't prove that extensionally equal
% functions are equal.

% Explain why we can't prove that isomorphic types are
% equal. Some silly example: list and list', where
% list' is just a primed copy of list.

\subsection{Caveats: decidable and heterogenous equality}
% Reminder: differences between differents kinds of
% "equality": decidable equality, homogenous equality
% and heterogenous equality.

\section{Axioms and classical logic}
% Explain how to declare axioms and that assuming an axiom
% breaks normalization (i.e programs built from axioms don't
% always compute).

% Example 1: functional extensionality axiom.
% Exmaple 2: excluded middle.

\section{How to find proofs}
% Because propositions are types and proofs are programs,
% finding proofs is basically the same as writing programs.
% All the techniques programmers already know, like splitting
% a function into subfunctions or refactoring some code into
% a separate functions have their exact equivalents (splitting
% a proof into lemmas and refactoring a part of a proofs into
% a lemma, respectively).

\section{Exercises}
% Some basic properties of connectives and quantifiers.
% Practice defining predicates and relations using inductive families.
% Implement some decision procedures for equality of numbers, prove
% some equational properties of numbers.

\begin{frame}{}
\begin{itemize}
	\item 
\end{itemize}
\end{frame}

\end{document}