\documentclass{beamer}

\usepackage{xcolor}

\newcommand{\m}[1]{\texttt{#1}}
\newcommand{\e}[1]{\textbf{#1}}

\title{Dependent Types and Theorem Proving: \\Introduction to Dependent Types}
\author{Wojciech Kołowski}
\date{March 2021}

\usetheme{Darmstadt}

\begin{document}

\frame{\titlepage}
\frame{\tableofcontents}

\section{Refinement types}

\begin{frame}{The problem of richness}
\begin{itemize}
    \item In dependently typed languages there is a lot of types.
    \item This is a blessing, because we can express all the complicated types and properties we need in order to guarantee correctness of our programs.
    \item But the richness of types also causes problems: it is often the case that there are many ways to define essentially the same type.
\end{itemize}
\end{frame}

\begin{frame}{The various faces of a \m{vec}tor 1/2}
\begin{itemize}
    \item We have already seen two incarnations of the type \m{vec a n} of vectors:
    \item Functional, recursive: by recursion on the index.
    \item Inductive, intrinsic: as an inductive family.
    \item But there are at least two more definitions:
    \item Functional, nonrecursive: as a function with domain \m{fin n}.
    \item Inductive, extrinsic: as a pair of a list and a proof that it's length is equal to \m{n}.
\end{itemize}
\end{frame}

\begin{frame}{The various faces of a \m{vec}tor 2/2}
\begin{itemize}
    \item A summary of downsides of each:
    \item Functional, recursive: ugly.
    \item Inductive, intrinsic: code duplication – it is necessary to reimplement common list functions (append, map, etc.).
    \item Functional, nonrecursive: ugly, higher-order representation, very difficult to implement functions (try to implement append if you don’t believe me).
    \item Inductive, extrinsic: a lot of boilerplate concerned with passing proofs around; need to reimplement list functions by wrapping them.
\end{itemize}
\end{frame}

\begin{frame}{Refinement types}
\begin{itemize}
    \item Refinement types are NOT dependent types!
    \item A refinement is just a different name for a function that returns bool.
    \item A refinement type is a type paired with a refinement.
    \item In F* syntax: \m{x \: a, p x} where \m{p \: a -> bool}.
\end{itemize}
\end{frame}

\begin{frame}{Code example no 6 - refinement types}
\begin{itemize}
    \item To better understand what the above slide tries to tell us, let's see the various definitions in code.
    \item See the code snippet \m{Lecture1/Vectors.fst}.
\end{itemize}
\end{frame}

% Introduce refinement types, using F* notation (i.e. x : int{x > 5}).
% Go over the head/tail example again, but this time using refinements
% on ordinary lists.

% Is it better to define indexed inductive types like vectors
% or go with ordinary inductive types and constrain them with
% predicates using dependent pairs? Well, neither and this
% leads us to...

\end{document}