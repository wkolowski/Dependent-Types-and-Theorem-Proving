\documentclass{beamer}

\title{Dependent Types and Theorem Proving: \\Introduction to Dependent Types}
\author{Wojciech KoÅ‚owski}
\date{March 2021}

\usetheme{Darmstadt}

\begin{document}

\frame{\titlepage}
\frame{\tableofcontents}

\section{Greetings}

% TODO: greetings

\begin{frame}{General info}
\begin{itemize}
	\item The lectures will be held weekly on Fridays.
	\item Don't worry if you miss a lecture -- the slides are pretty massive and the talks are going to be recorded.
	\item Each lecture ends with some exercises which will help you familiarize yourself with F* and better understand the ideas covered in the talk.
	\item But you don't need to do them if you don't want to.
\end{itemize}
\end{frame}

\begin{frame}{Plan of lectures}
\begin{itemize}
	\item Lecture 1: Programming with dependent types.
	\item Lecture 2: Proving theorems with dependent types.
	\item Lecture 3: Differences between programming and proving.
	\item Lecture 4: Examples of bigger programs and longer proofs.
	\item Lecture 5: A deeper dive into F*.
\end{itemize}
\end{frame}

% Learning outcomes:
% - after listening to the lectures people shouldn't be scared of dependent
%   types and formal proofs anymore
% - if additionally they do some exercises, they should end up pretty good at
%   basic proving (up to quantifiers), but maybe still struggling with stuff
%   like defining inductive predicates

\begin{frame}{Learning outcomes}
\begin{itemize}
	\item You won't be scared of all those obscure, scary and mysterious names and notations.
	\item You will get basic familiarity with the ideas behind dependent types.
	\item You will begin to see logic and mathematics in a very different light, much closer to your day job (at least if you are a programmer working in F\#).
	\item If you do the exercises, you will gain a basic proficiency in F*.
\end{itemize}
\end{frame}

\begin{frame}{Introducing F* 1/2}
\begin{itemize}
	\item F* (pronounced ``eff star'') is a general-purpose purely functional programming language.
	\item It comes from the ML family of languages. Its syntax most closely resembles that of F\#.
	\item It is aimed at program verification, i.e. first you write a program and then you prove theorems which say that there are no bugs in the program. This will be covered in lecture 2.
	\item It has traditional dependent types similar to those found in Coq, Agda, Lean or Idris. They are covered in lecture 1, i.e. today.
	\item It also has refinement types, a different flavour of dependent types which is better suited for automatic theorem proving (traditional dependent types are more suited for ``manual'' proving). They are covered in lecture 1, i.e. today.
	\item It has an effect system. This is a thing similar to what can be done with monads in Haskell. We will see it in lecture 3.
\end{itemize}
\end{frame}

\begin{frame}{Introducing F* 1/2}
\begin{itemize}
	\item F* also has some more features which are unusual for functional languages, like mutable references and a weakest precondition calculus. These will be covered in lecture 5 or not at all.
	\item F* is NOT a .NET language.
	\item F* is neither compiled nor interpreted -- it is mostly a typechecker.
	\item To run an F* program, it has to be extracted to some other language, like F\# or OCaml, and then compiled.
\end{itemize}
\end{frame}

\begin{frame}{F* ecosystem}
\begin{itemize}
	\item You can run F* inside your browser (and have a nice tutorial guide you): \url{http://www.fstar-lang.org/tutorial/}
	\item Homepage: \url{http://www.fstar-lang.org/}
	\item GitHub: \url{https://github.com/FStarLang/FStar}
	\item Download: \url{http://www.fstar-lang.org/\#download}
	\item Papers (not approachable for ordinary mortals): \url{http://www.fstar-lang.org/\#papers}
	\item Talks/presentations (more approahcable): \url{http://www.fstar-lang.org/\#talks} (some of these are quite approachable if you're interested)  
\end{itemize}
\end{frame}

% The lectures are mostly aimed at people who know some F# and are comfortable
% with pattern matching, recursion, algebraic data types etc.

\begin{frame}{Prerequisites}
\begin{itemize}
	\item 
\end{itemize}
\end{frame}

\section{General idea}
% A definition of dependent types (types that can depend on values) and an
% example -- a good one would be the type of MxN matrices.

\section{First-class types}

\subsection{What does ``first-class'' mean?}
% Explain the notion of "first-class" using the (lack of) first class functions
% in C (and maybe something else) as an example.

% Then introduce the universe of types. At this stage we will pretend that
% Type : Type. Mentioning the universe hierarchy should be postponed to lecture 3.

\subsection{Computing with types}
% Show that our functions can now juggle types the same way they can juggle
% integers or strings.

% Leading example: compute printf's type from format string.

\section{Dependent functions}
% Introduce pi types by analogy with ordinary function type.
% Always call it "dependent function type" and use F* notation
% (i.e. (x : A) -> P x) to minimize confusion.

% Show some silly examples, like returning results of different types in
% different if-branches. Maybe compare this to dynamic typing and underline
% the differences.

\subsection{Example: typesafe printf}
% Finish the typesafe printf example.

\subsection{How to express polymorphism}
% Polymorphic functions are just dependent functions with Type arguments.
% Mention how this relates to type constructors, i.e. list : Type -> Type.

\subsection{Implicit arguments and how to read function signatures}
% Mention that with dependent types, we can infer some arguments from
% the types of others, so we don't want to explicitly write all arguments.

\section{Dependent pairs}
% Introduce sigma types by analogy with ordinary products.
% Always call it "dependent pair type" and use F* notation
% (i.e. (x : A) * P x) to minimize confusion.

\subsection{Example: everybody loves filling forms}
% An example, something along the lines of how to use dependent pairs
% to avoid forms with "not applicable" fields.

\section{Optional: some arithmetic}
% An optional section.

\subsection{Sigma}
% Introduce the sigma notation for dependent pair types.
% Explain it by parallels with math's sigma notation for
% addition. Introduce the name "dependent sum (type)".

\subsection{Pi}
% Introduce the pi notation for dependent function types.
% Explain it by parallels with math's pi notation for
% multiplication. Introduce the name "dependent product (type)".

\subsection{Plus, cross and arrow}
% Explain that dependent pair types are a generalization of
% both sum types and product types.

% Explain that dependent function types are a generalization of
% both product types and function types.

\section{Inductive families}
% Refresher on ordinary algebraic data types.
% Introduce inductive families by analogy with ordinary algebraic
% data types.

\subsection{Example: length-indexed lists}
% Vectors - the canonical example of an inductive family.
% Mention problems with partial functions like head and tail
% and how to turn them into total functions on vectors.

\subsection{Example: enforcing protocols}
% Look up Idris tutorials/manuals/books for some example
% on how to use inductive families for enforcing protocols,
% i.e. for using sockets.

\section{Intrinsic vs extrinsic style}
% Is it better to define indexed inductive types like vectors
% or go with ordinary inductive types and constrain them with
% predicates using dependent pairs? Well, neither and this
% leads us to...

\section{Refinement types}
% Introduce refinement types, using F* notation (i.e. x : int{x > 5}).
% Go over the head/tail example again, but this time using refinements
% on ordinary lists.

\section{Exercises}
% No idea yet.

\end{document}