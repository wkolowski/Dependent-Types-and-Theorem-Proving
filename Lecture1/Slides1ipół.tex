\documentclass{beamer}

\usepackage{xcolor}

\newcommand{\m}[1]{\texttt{#1}}
\newcommand{\e}[1]{\textbf{#1}}

\title{Dependent Types and Theorem Proving: \\Introduction to Dependent Types}
\author{Wojciech KoÅ‚owski}
\date{March 2021}

\usetheme{Darmstadt}

\begin{document}

\frame{\titlepage}
\frame{\tableofcontents}

\section{Inductive types}
% Refresher on ordinary algebraic data types.
% Introduce inductive families by analogy with ordinary algebraic
% data types.

\begin{frame}{Inductive types are discriminated unions}
\begin{itemize}
	\item Recall how ordinary inductive types work in F\# (where they are called discriminated unions).
	\item To define an inductive type \m{I :\ Type}, we list its constructors.
	\item The constructors are ordinary functions which take some arguments and return an element of the type.
	\item To create an element of \m{I}, we use one of the constructors and provide it with the arguments it requires.
	\item To use an element of \m{I}, we pattern match on it and for each case we provide an expression which will be computed if that case matches.
\end{itemize}
\end{frame}

\begin{frame}{Inductive families}
\begin{itemize}
	\item Now watch the analogy unfold...
	\item To define an \textbf{inductive family} \m{I : (\#a :\ Type) -> a -> Type}, we list its constructors.
	\item \textbf{The constructors are dependent functions which take some arguments and return an element of the type} \m{I x}, where \m{x :\ a} was constructed from the arguments.
	\item To create an element of \m{I x}, we use one of the constructors and provide it with the arguments it requires.
	\item To use an element of \m{I x}, we pattern match on it and for each case we provide an expression which will be computed if that case matches.
\end{itemize}
\end{frame}

\begin{frame}{Code snippet no 5 - inductive families in F*}
\begin{itemize}
	\item Let's see how inductive families work in F*.
	\item See the code snippet \m{Lecture1/InductiveFamilies.fst}
\end{itemize}
\end{frame}

\begin{frame}{The running summary 5}
\begin{itemize}
	\item Dependent types are types that can depend on values.
	\item In dependently typed languages:
	\item There is a universe -- a type whose elements are themselves types.
	\item There is a type of dependent functions which are just like ordinary functions, but their output TYPE can depend on the VALUE of their input.
	\item Dependent record types are just like ordinary records, but the TYPES of later fields can depend on the VALUE of earlier fields.
	\item Inductive families are just like ordinary inductive types, but the TYPES in the family can depend on the VALUE of the index.
\end{itemize}
\end{frame}

\begin{frame}{Inductive types and polynomials 1/2}
\begin{itemize}
	\item An inductive type is \textbf{EITHER} constructor 1 applied to arguments \m{x1} \textbf{and} \m{x2} \dots \textbf{and} \m{xN} \textbf{OR} constructor 2 applied to arguments \dots \textbf{OR} constructor M applied to arguments \dots
	\item In math, OR means \textbf{addition}, whereas AND means \textbf{multiplication}.
	\item So, an inductive type boils down to a \textbf{Sum of Products}.
	\item These products are made of two kinds of arguments: recursive arguments (whose type is the inductive type that is being defined) and non-recursive ones.
	\item If you think about it long enough, \textbf{inductive types correspond to polynomials}!
\end{itemize}
\end{frame}

\begin{frame}{Inductive types and polynomials 2/2}
\begin{itemize}
	\item This could be hard to swallow, so let's see examples.
	\item Lists satisfy the equation $\m{List}(A) = 1 + A \times \m{List}(A)$.
	\item Here $1$ corresponds to the \m{nil} constructor, whereas the $A$ and $\m{List}(A)$ on the right correspond to the arguments of the \m{cons} constructor.
	\item This corresponds to the polynomial $F(X) = 1 + A \times X$.
	\item $\m{List}(A)$ is the least fixed point of this polynomial, i.e. the smallest type $X$ that satisfies $F(X) = X$.
	\item Here ``fixed point'' corresponds to the fact that we create lists using constructors (\m{nil} and \m{cons}), whereas ``least'' corresponds to the fact that all lists are made of finitely many constructors.
\end{itemize}
\end{frame}

\subsection{Example: length-indexed lists}
% Vectors - the canonical example of an inductive family.
% Mention problems with partial functions like head and tail
% and how to turn them into total functions on vectors.

\subsection{Example: enforcing protocols}
% Look up Idris tutorials/manuals/books for some example
% on how to use inductive families for enforcing protocols,
% i.e. for using sockets.

\subsection{Intrinsic vs extrinsic style}
% Is it better to define indexed inductive types like vectors
% or go with ordinary inductive types and constrain them with
% predicates using dependent pairs? Well, neither and this
% leads us to...

\section{Refinement types}
% Introduce refinement types, using F* notation (i.e. x : int{x > 5}).
% Go over the head/tail example again, but this time using refinements
% on ordinary lists.

\section{Exercises}
% No idea yet.

\end{document}