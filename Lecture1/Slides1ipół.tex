\documentclass{beamer}

\usepackage{xcolor}

\newcommand{\m}[1]{\texttt{#1}}
\newcommand{\e}[1]{\textbf{#1}}

\title{Dependent Types and Theorem Proving: \\Introduction to Dependent Types}
\author{Wojciech KoÅ‚owski}
\date{March 2021}

\usetheme{Darmstadt}

\begin{document}

\frame{\titlepage}
\frame{\tableofcontents}

\section{Inductive families}
% Refresher on ordinary algebraic data types.
% Introduce inductive families by analogy with ordinary algebraic
% data types.

\begin{frame}{Inductive types are algebraic data types}
\begin{itemize}
	\item \textbf{Inductive types} are another name for what is in Haskell known as \textbf{algebraic data types} and in F\# as \textbf{discriminated unions}.
	\item They are made using constructors (known in F\# as union cases), for example lista are either nil or cons.
	\item 
\end{itemize}
\end{frame}

\subsection{Example: length-indexed lists}
% Vectors - the canonical example of an inductive family.
% Mention problems with partial functions like head and tail
% and how to turn them into total functions on vectors.

\subsection{Example: enforcing protocols}
% Look up Idris tutorials/manuals/books for some example
% on how to use inductive families for enforcing protocols,
% i.e. for using sockets.

\subsection{Intrinsic vs extrinsic style}
% Is it better to define indexed inductive types like vectors
% or go with ordinary inductive types and constrain them with
% predicates using dependent pairs? Well, neither and this
% leads us to...

\section{Refinement types}
% Introduce refinement types, using F* notation (i.e. x : int{x > 5}).
% Go over the head/tail example again, but this time using refinements
% on ordinary lists.

\section{Exercises}
% No idea yet.

\end{document}