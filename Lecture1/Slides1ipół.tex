\documentclass{beamer}

\usepackage{xcolor}

\newcommand{\m}[1]{\texttt{#1}}
\newcommand{\e}[1]{\textbf{#1}}

\title{Dependent Types and Theorem Proving: \\Introduction to Dependent Types}
\author{Wojciech KoÅ‚owski}
\date{March 2021}

\usetheme{Darmstadt}

\begin{document}

\frame{\titlepage}
\frame{\tableofcontents}

\section{Records}

\begin{frame}{Non-dependent pairs}
\begin{itemize}
	\item Recall how ordinary pairs work in F\#.
	\item If \m{a :\ Type} is a type and \m{b :\ Type} is a type, then there is a type \m{a * b :\ Type} of pairs.
	\item To create a pair, we write \m{(x, y)} where \m{x} is of type \m{a} and \m{y} is of type \m{b}.
	\item To use a pair \m{p :\ a * b}, we use projections -- we have \m{fst p :\ a} and \m{snd p :\ b}.
	\item We can also pattern match on pairs.
\end{itemize}
\end{frame}

\begin{frame}{Dependent pairs}
\begin{itemize}
	\item Now, watch the analogy unfold\dots
	\item If \m{a :\ Type} is a type and \textbf{\m{b :\ a -> Type} is a family of types}, then there is \textbf{a type \m{(x :\ a) \& b x :\ Type} of dependent pairs}.
	\item To create a dependent pair, we write \m{(| x, y |)} where \m{x} is of type \m{a} \textbf{and \m{y} is of type \m{b x}}.
	\item To use a pair \m{p :\ (x :\ a) \& b x}, we use projections -- we have \m{fst p :\ a} and \m{snd p :\ b (fst p)} (\textbf{note that the type of the second projection depends on the value of the first projection}).
	\item We can also pattern match on dependent pairs.
\end{itemize}
\end{frame}

\begin{frame}{More dependent pairs}
\begin{itemize}
	\item \textbf{We can iterate the dependent pair type}, while dropping unneeded parentheses -- analogously to what we did for dependent functions.
	\item \m{(x :\ a) \& b x}
	\item \m{(x :\ a) \& (y :\ b x) \& c x y}
	\item \m{(x :\ a) \& (y :\ b x) \& (z :\ c x y) \& d x y z}
	\item \textbf{But using iterated dependent pairs is very inconvenient!}
	\item To access component of a dependent quadruple \m{p} we would have to write \m{fst p}, \m{fst (snd p)}, \m{fst (snd (snd p))} and \m{snd (snd (snd p))}.
\end{itemize}
\end{frame}

\begin{frame}{Dependent record types}
\begin{itemize}
	\item There's a better way than iterating dependent pair types: dependent record types.
	\item A record is basically a labeled tuple.
	\item \textbf{A dependent record is basically a labeled dependent tuple}.
	\item This means that the TYPES of later fields in a dependent record can depend on the VALUES of earlier fields.
\end{itemize}
\end{frame}

\begin{frame}{Code snippet no 4 - dependent records in F*}
\begin{itemize}
	\item Let's see how dependent records work in F*.
	\item See the code snippet \m{Lecture1/DependentRecords.fst}
\end{itemize}
\end{frame}

\begin{frame}{The running summary 4}
\begin{itemize}
	\item Dependent types are types that can depend on values.
	\item In dependently typed languages:
	\item There is a universe -- a type whose elements are themselves types.
	\item There is a type of dependent functions which are just like ordinary functions, but their output TYPE can depend on the VALUE of their input.
	\item \textbf{Dependent record types are just like ordinary records, but the TYPES of later fields can depend on the VALUE of earlier fields}.
\end{itemize}
\end{frame}

\section{Life of Pi}

\begin{frame}{Pi type and multiplication}
\begin{itemize}
	\item The dependent function type \textbf{is also known as the Pi type}.
	\item \textbf{This name comes from a notation}: \m{(x :\ a) -> b x} is sometimes written as $\displaystyle \prod_{x :\ a} b(x)$.
	\item \textbf{This notation comes from an analogy with multiplication}. In math $\displaystyle \prod_{k = 0}^n a_k$ means $a_0 \cdot a_1 \cdot ... \cdot a_n$.
	\item \textbf{We can think about dependent function types in this way too}. For example, the type \m{(x :\ bool) -> p x} is equivalent to \m{p true * p false}.
	\item The result of multiplication is called a product, hence the dependent function type \textbf{is also known as the dependent product type}.
	\item As it turns out, the dependent function type \textbf{generalizes both the ordinary function type and the product type}, but in different ways.
\end{itemize}
\end{frame}

\begin{frame}{Sigma type and addition}
\begin{itemize}
	\item The dependent pair type \textbf{is also known as the Sigma type}.
	\item \textbf{This name comes from a notation}: \m{(x :\ a) \& b x} is sometimes written as $\displaystyle \sum_{x :\ a} b(x)$.
	\item \textbf{This notation comes from an analogy with addition}. In math $\displaystyle \sum_{k = 0}^n a_k$ means $a_0 + a_1 + ... + a_n$.
	\item \textbf{We can think about dependent pair types in this way too}. For example, the type \m{(x :\ bool) \& p x} is equivalent to \m{p true + p false} (where \m{+} just means a simple tagged union).
	\item The result of addition is called a sum, hence the dependent pair type \textbf{is also known as the dependent sum type}.
	\item As it turns out, the dependent pair type \textbf{generalizes both the product type and the sum type}, but in different ways.
\end{itemize}
\end{frame}

\section{Inductive families}
% Refresher on ordinary algebraic data types.
% Introduce inductive families by analogy with ordinary algebraic
% data types.

\subsection{Example: length-indexed lists}
% Vectors - the canonical example of an inductive family.
% Mention problems with partial functions like head and tail
% and how to turn them into total functions on vectors.

\subsection{Example: enforcing protocols}
% Look up Idris tutorials/manuals/books for some example
% on how to use inductive families for enforcing protocols,
% i.e. for using sockets.

\section{Intrinsic vs extrinsic style}
% Is it better to define indexed inductive types like vectors
% or go with ordinary inductive types and constrain them with
% predicates using dependent pairs? Well, neither and this
% leads us to...

\section{Refinement types}
% Introduce refinement types, using F* notation (i.e. x : int{x > 5}).
% Go over the head/tail example again, but this time using refinements
% on ordinary lists.

\section{Exercises}
% No idea yet.

\end{document}