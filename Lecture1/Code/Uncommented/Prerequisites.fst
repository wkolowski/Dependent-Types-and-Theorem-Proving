module Prerequisites

// Single line comments.
(*
    Multiline comments look like this.
*)

let x = 5

let y : int = 5

val z : int
let z = 42

let rec fib (n : int) : int =
    if n <= 0
    then 0
    else
        if n = 1
        then 1
        else fib (n - 1) + fib (n - 2)




let f = fun (_ : int) -> 42


let twice f x = f (f x)


let twice' (f : int -> int) : int -> int =
    fun (n : int) -> f (f n)









type intOrString =
    | Left of int
    | Right of string


let an_int : intOrString = Left 42
let a_string : intOrString = Right "forty two"



let show (x : intOrString) : string =
    match x with
    | Left _ -> "an integer"
    | Right s -> s




let l : int -> intOrString = Left
let r : string -> intOrString = Right




type intOrString' =
    | Left'  : int    -> intOrString'
    | Right' : string -> intOrString'




let swap (p : int * string) : string * int =
    (snd p, fst p)


let swap' p =
    match p with
    | (x, y) -> (y, x)



let swap'' (x, y) = (y, x)





type stuff =
{
    num : int;
    str : string;
    bl  : bool;
}


let someStuff : stuff =
{
    num = 42;
    str = "Hello there!";
    bl  = false;
}


let double_num (s : stuff) : int = s.num + s.num


let double_num' (s : stuff) : int =
    let open s <: stuff in num + num




let double_num'' (s : stuff) : int =
    match s with
    | Mkstuff num str bl -> num + num


type stuff' =
    | Mkstuff' : int -> string -> bool -> stuff'


let num' (Mkstuff' i _ _) = i
let str' (Mkstuff' _ s _) = s
let bl'  (Mkstuff' _ _ b) = b



type stuff'' =
    | Mkstuff'' : (num : int) -> (str : string) -> (bl : bool) -> stuff''

let autogenerated_projection : stuff'' -> int =
    Mkstuff''?.num













let curry (f : int * string * bool -> stuff') : int -> string -> bool -> stuff' =
    fun i s b -> f (i, s, b)

let uncurry (f : int -> string -> bool -> stuff') : int * string * bool -> stuff' =
    fun p ->
        match p with
        | (i, s, b) -> f i s b






type binaryTree =
    | Empty : binaryTree
    | Node  : int -> binaryTree -> binaryTree -> binaryTree

let a_tree : binaryTree =
    Node 1000
        (Node 500 Empty Empty)
        (Node 2000
            (Node 1500 Empty Empty)
            Empty)



let rec mirror (t : binaryTree) : binaryTree =
    match t with
    | Empty -> Empty
    | Node value left right -> Node value (mirror right) (mirror left)