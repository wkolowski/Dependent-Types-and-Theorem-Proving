\documentclass{beamer}

\usepackage{xcolor}

\newcommand{\m}[1]{\texttt{#1}}

\title{Dependent Types and Theorem Proving: \\Introduction to Dependent Types}
\author{Wojciech KoÅ‚owski}
\date{March 2021}

\usetheme{Darmstadt}

\begin{document}

\frame{\titlepage}
\frame{\tableofcontents}

\section{Greetings}

\begin{frame}{General info}
\begin{itemize}
	\item The lectures will be held weekly on Fridays.
	\item Don't worry if you miss a lecture -- the slides are pretty massive and the talks are going to be recorded.
	\item Each lecture ends with some exercises which will help you familiarize yourself with F* and better understand the ideas covered in the talk.
	\item But you don't need to do them if you don't want to.
	\item This talks repo: \url{https://github.com/wkolowski/Dependent-Types-and-Theorem-Proving}
\end{itemize}
\end{frame}

\begin{frame}{Plan of lectures}
\begin{itemize}
	\item Lecture 1: Programming with dependent types.
	\item Lecture 2: Proving theorems with dependent types.
	\item Lecture 3: Differences between programming and proving.
	\item Lecture 4: Examples of bigger programs and longer proofs.
	\item Lecture 5: A deeper dive into F*.
\end{itemize}
\end{frame}

\begin{frame}{Learning outcomes}
\begin{itemize}
	\item You won't be scared of all those obscure, scary and mysterious names and notations.
	\item You will get basic familiarity with the ideas behind dependent types.
	\item You will begin to see logic and mathematics in a very different light, much closer to your day job (at least if you are a programmer working in F\#).
	\item If you do the exercises, you will gain a basic proficiency in F*.
\end{itemize}
\end{frame}

\begin{frame}{Introducing F*}
\begin{itemize}
	\item F* (pronounced ``eff star'') is a general-purpose purely functional programming language.
	\item Member of the ML family, syntactically most similar to F\#.
	\item Aimed at program verification.
	\item Dependent types.
	\item Refinement types.
	\item Effect system.
	\item Not a .NET language.
	\item Neither compiled nor interpreted -- it's a proof assistant, i.e. just a typechecker.
	\item To run a program, it has to be extracted to some other language, like F\#, OCaml, C or WASM, and then compiled.
\end{itemize}
\end{frame}

\begin{frame}{Don't worry, be happy, ask lots of questions}
\begin{center}
	\color{red}
	I KNOW YOU DIDN'T UNDERSTAND THE PREVIOUS SLIDE, BUT BY THE END OF THESE TALKS, YOU WILL -- AND THAT'S THE POINT!
\end{center}
\end{frame}

\begin{frame}{Useful F* links}
\begin{itemize}
	\item You can run F* inside your browser (and have a nice tutorial guide you): \url{http://www.fstar-lang.org/tutorial/}
	\item GitHub: \url{https://github.com/FStarLang/FStar}
	\item Homepage: \url{http://www.fstar-lang.org/}
	\item Download: \url{http://www.fstar-lang.org/\#download}
	\item Papers (not approachable for ordinary mortals): \url{http://www.fstar-lang.org/\#papers}
	\item Talks/presentations (more approachable): \url{http://www.fstar-lang.org/\#talks} (some of these are quite approachable if you're interested)  
\end{itemize}
\end{frame}

\begin{frame}{Prerequisites}
\begin{itemize}
	\item To understand what we will be talking about, you should have a working knowledge of F\# and the basic concepts of functional programming, namely:
	\item Functions as first-class citizens, including higher-order functions.
	\item Algebraic data types, including sum types and product types.
	\item Pattern matching and recursion.
	\item Even if you know these, you may be unfamiliar with the particular names -- for example, ``sum types'' is a name used in academia and Haskell, but in F\# they are better known as ``tagged unions''.
	\item We will now see some code that shows how these things look in F* (see the file \texttt{Lecture1/Prerequisites.fst}).
\end{itemize}
\end{frame}

% A definition of dependent types (types that can depend on values) and an
% example -- a good one would be the type of MxN matrices.
\section{General idea}

\begin{frame}{Dependencies}
\begin{itemize}
	\item To understand dependent types, first we have to understand dependency. It's easiest to do this by listing the forms of dependency you are likely to be familiar with:
	\item Values can depend on values: we can think that the sum \m{n + m} is a number that depends on the numbers \m{n} and \m{m}. This dependency can be expressed as a function: \m{fun (n m :\ int) -> n + m}.
	\item Values can depend on types. For example, the identity function \m{fun (x :\ 'a) -> x} depends on the type \m{'a}.
	\item Types can depend on types. For example, the F\# type \m{Set<'a>} depends on the type \m{'a}.
\end{itemize}
\end{frame}

\begin{frame}{Naming the dependencies}
\begin{itemize}
	\item I bet you spotted the pattern in the previous slide, but it's a good idea to also have a name for the feature provided by each kind of dependency.
	\item Values can depend on values: (first-class) functions.
	\item Values can depend on types: polymorphism (i.e. ``generics'').
	\item Types can depend on types: type operators.
\end{itemize}
\end{frame}

\begin{frame}{Dependent types}
\begin{itemize}
	\item There's yet another kind of dependency, which is not present in F\#, but is present in F* and is the topic of this lecture.
	\item Types can depend on values: dependent types.
	\item But what are dependent types good for? You have been living your whole life without them, after all!
\end{itemize}
\end{frame}

\begin{frame}{Matrix multiplication}
\begin{itemize}
	\item We can only multiply matrices whose dimensions match, i.e. we can multiply an $n \times m$ matrix by a $m \times k$ and get an $n \times k$ matrix as a result.
	\item How to model this in our favourite programming language without dependent types?
	\item The best we can do is to have a types of matrices \m{Matrix} and then matrix multiplication has type \m{matmult :\ Matrix -> Matrix -> Matrix}.
	\item What happens when we call it with matrices of the wrong dimensions?
	\item $\m{matmult} \begin{bmatrix}1 & 2\\3 & 4\end{bmatrix} \begin{bmatrix}1 & 2 & 3\\4 & 5 & 6\\7 & 8 & 9\end{bmatrix}$ is well-typed, but will throw an \m{IllegalArgumentException} or some other kind of runtime error, or maybe it will crash even less gracefully.
\end{itemize}
\end{frame}

\begin{frame}{Matrix multiplication with dependent types}
\begin{itemize}
	\item In a language with dependent types we can create a type \m{Matrix n m} of $n \times m$ matrices and give multiplication the type \m{matmult : (n :\ $\mathbb{N}$) ->  (m :\ $\mathbb{N}$) -> (k :\ $\mathbb{N}$) -> Matrix n m -> Matrix m k -> Matrix n k}
	\item Now \m{matmult} is a function which takes five arguments: the three matrix dimensions and the two matrices themselves.
	\item After giving it the dimensions of the first matrix from the previous slide, \m{matmult 2 2} has type \m{(k :\ $\mathbb{N}$) -> Matrix 2 2 -> Matrix 2 3 -> Matrix 2 3}.
	\item It is clear that \m{matmult 2 2 k} $\begin{bmatrix}1 & 2\\3 & 4\end{bmatrix} \begin{bmatrix}1 & 2 & 3\\4 & 5 & 6\\7 & 8 & 9\end{bmatrix}$ is not well-typed for any \m{k}, because the last argument is of type \m{Matrix 3 3}, but an argument of type \m{Matrix 2 k} was expected.
\end{itemize}
\end{frame}

\begin{frame}{Array access}
\begin{itemize}
	\item When accessing the $i$-th element of an array, $i$ must be smaller than the length of the array.
	\item How to model this in our favourite programming language without dependent types?
	\item We have a type \m{Array A} of arrays whose elements are of type \m{A} and we can access its elements with a function \m{get :\ Array A -> int -> A}.
	\item What happens, when $i$ is greater than the length of the array? Or, what happens when $i$ is negative?
	\item \m{get [| 'a'; 'b'; 'c' ] 5} is well-typed, but will throw an \m{IndexOutOfBoundsException} or result in a segmentation fault.
\end{itemize}
\end{frame}

\begin{frame}{Array access with dependent types 1/2}
\begin{itemize}
	\item In a language with dependent types we can have a type \m{Array A n} of arrays holding elements of type \m{A} and whose length is the natural number \m{n}.
	\item Then we have a few possibilities to model the type of \m{get}.
	\item \m{get :\ (n :\ $\mathbb{N}$) -> Array A n -> (i :\ $\mathbb{N}$) -> i < n -> A}.
	\item In this variant, the fourth argument of \m{get} is a proof that the index isn't out of bounds (we will cover proofs in the next lecture).
	\item We can't prove \m{5 < 3}, so we don't have any proof to feed into \m{get 3 [| 'a'; 'b'; 'c' |] 5 :\ 5 < 3 -> Char}.
\end{itemize}
\end{frame}

\begin{frame}{Array access with dependent types 2/2}
\begin{itemize}
	\item \m{get :\ (n :\ $\mathbb{N}$) -> Array A n -> (i :\ $\mathbb{N}$\{i < n \}) -> A}.
	\item In this variant we use refinement types (which we will cover later today) to automatically guarantee that \m{i} isn't out of bounds.
	\item \m{get 3 [| 'a'; 'b'; 'c' |] 5} is not well-typed, because the typechecker can't prove \m{5 < 3}, and thus \m{5} is not of type \m{$\mathbb{N}$\{5 < 3\}}.
\end{itemize}
\end{frame}

\section{First-class types}

\begin{frame}{}
\begin{itemize}
	\item 
\end{itemize}
\end{frame}

\subsection{What does ``first-class'' mean?}
% Explain the notion of "first-class" using the (lack of) first class functions
% in C (and maybe something else) as an example.

% Then introduce the universe of types. At this stage we will pretend that
% Type : Type. Mentioning the universe hierarchy should be postponed to lecture 3.

\subsection{Computing with types}
% Show that our functions can now juggle types the same way they can juggle
% integers or strings.

% Leading example: compute printf's type from format string.

\section{Dependent functions}
% Introduce pi types by analogy with ordinary function type.
% Always call it "dependent function type" and use F* notation
% (i.e. (x : A) -> P x) to minimize confusion.

% Show some silly examples, like returning results of different types in
% different if-branches. Maybe compare this to dynamic typing and underline
% the differences.

\subsection{Example: typesafe printf}
% Finish the typesafe printf example.

\subsection{How to express polymorphism}
% Polymorphic functions are just dependent functions with Type arguments.
% Mention how this relates to type constructors, i.e. list : Type -> Type.

\subsection{Implicit arguments and how to read function signatures}
% Mention that with dependent types, we can infer some arguments from
% the types of others, so we don't want to explicitly write all arguments.

\section{Dependent pairs}
% Introduce sigma types by analogy with ordinary products.
% Always call it "dependent pair type" and use F* notation
% (i.e. (x : A) * P x) to minimize confusion.

\subsection{Example: everybody loves filling forms}
% An example, something along the lines of how to use dependent pairs
% to avoid forms with "not applicable" fields.

\section{Optional: some arithmetic}
% An optional section.

\subsection{Sigma}
% Introduce the sigma notation for dependent pair types.
% Explain it by parallels with math's sigma notation for
% addition. Introduce the name "dependent sum (type)".

\subsection{Pi}
% Introduce the pi notation for dependent function types.
% Explain it by parallels with math's pi notation for
% multiplication. Introduce the name "dependent product (type)".

\subsection{Plus, cross and arrow}
% Explain that dependent pair types are a generalization of
% both sum types and product types.

% Explain that dependent function types are a generalization of
% both product types and function types.

\section{Inductive families}
% Refresher on ordinary algebraic data types.
% Introduce inductive families by analogy with ordinary algebraic
% data types.

\subsection{Example: length-indexed lists}
% Vectors - the canonical example of an inductive family.
% Mention problems with partial functions like head and tail
% and how to turn them into total functions on vectors.

\subsection{Example: enforcing protocols}
% Look up Idris tutorials/manuals/books for some example
% on how to use inductive families for enforcing protocols,
% i.e. for using sockets.

\section{Intrinsic vs extrinsic style}
% Is it better to define indexed inductive types like vectors
% or go with ordinary inductive types and constrain them with
% predicates using dependent pairs? Well, neither and this
% leads us to...

\section{Refinement types}
% Introduce refinement types, using F* notation (i.e. x : int{x > 5}).
% Go over the head/tail example again, but this time using refinements
% on ordinary lists.

\section{Exercises}
% No idea yet.

\end{document}